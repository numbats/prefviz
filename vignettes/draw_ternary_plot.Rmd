---
title: "Using `ternable` object to draw ternary plots"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{draw_ternary_plot}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)
```

```{r setup}
library(prefviz)
library(ggplot2)
library(tourr)
```

This vignette shows you how to build a ternary plot on 2 and higher dimensions, using the `ternable` object.

Both 2D and high-dimensional (HD) ternary plots require the following 3 components:

- Coordinates of the observations: TBD
- Vertices: The point coordinates that define the vertices of the simplex
- Edges: How the vertices are connected to create the simplex

Below is the illustration of these 3 components in the simplest case of ternary plots, which is a 2D ternary plot:

[add some illustration]

You can access all these components conveniently via a `ternable` object.

# `ternable` object

`ternable` is a simple S3 object that contains all the data and metadata useful for ternary plots, including the following components:

- `data`: Stores input data after being validated and normalized
- `ternary_coord`: Stores the coordinates for all observations.
- `simplex_vertices`: Stores the coordinates of the vertices of the simplex.
- `simplex_edges`: Stores the connections between the vertices of the simplex.
- `alternatives`: Stores the names of the alternatives in the order provided in the argument `alternatives`.

To create a `ternable` object, simply call the function `ternable()`. `ternable()` takes 2 arguments:

- `data`: The input data, which must be in a `ternable`-friendly format. For more details on how to transform your raw data into a `ternable`-friendly format, please refer to the tutorial[Transforming voting data to ternable-friendly format](transform_raw_data.html).
- `alternatives`: The names of the alternatives in the order you want them to appear in the ternary plot. The default takes all the columns in `data`.

```{r}
head(aecdop22_transformed)

tern22 <- ternable(aecdop22_transformed, ALP:Other)
tern22
```

## `ternable` helpers - `get_tern_*()`

`ternable` provides you with the essenstial components for building a ternary plot. However, different plot types (2D or HD) might require slightly different way of representing these commponents. So, `get_tern_*()` functions help you do just that. 

Under the hood, `get_tern_*()` perform simple data transformations, i.e., `rbind()` and `cbind()`, to help you create the input that are compatible with popular plotting packages, which are `ggplot2` for 2D ternary plot and `tourr` for HD ternary plots.

There are 3 `get_tern_*()` functions:

- `get_tern_data()`: Provides input data for `ggplot2` or `tourr`.
- `get_tern_edges()`: Provides edges of the simplex, which is required by `tourr`. 
- `get_tern_labels()`: Provides labels for the vertices, which is helpful for distinguishing vertices in `tourr`.

# Drawing a 2D ternary plot

Take the example of the 2022 Australian Federal Election, we would like to take a look at the first preference distribution between the 2 major parties: Labor and the Coalition, and other parties. 

The dataset `aecdop22_transformed` is already in a `ternable`-friendly format, so we can directly pass it to `ternable()` to create a `ternable` object.

```{r}
tern22 <- ternable(aecdop22_transformed, ALP:Other)
```

Now we can use the `get_tern_data()` function to get the input data for `ggplot2`.

```{r}
input_df <- get_tern_data(tern22, plot_type = "2D")
head(input_df)
```

The output is a data frame where the original columns (`DivisionNm` to `Other`) are combined with the coordinates (`x1`, `x2`). These coordinate columns are the observation locations on the plot. We can now use `ggplot2` to draw the ternary plot.

```{r}
library(ggplot2)

p <- ggplot(input_df, aes(x = x1, y = x2)) +
  geom_ternary_cart() + # Draw the ternary space as an equilateral triangle
  geom_point(aes(color = ElectedParty)) + # Plot the observations as points
  add_vertex_labels(tern22$simplex_vertices) + # Add vertex labels, taken from the ternable object
  labs(title = "First preference in 2022 Australian Federal election")

p
```

In an election, we would be interested in defining the regions where one party takes the majority over others. We can do that using `geom_ternary_region()`. 

This geom takes the barycentric coordinates of a reference point as input, and divides the ternary triangle into 3 regions based on the reference points. These regions are defined by the perpendicular projections of the reference point to the three edges of the triangle. The default reference point is the centroid, which divides the triangle into 3 equal regions.

```{r}
p + 
  geom_ternary_region(
    x1 = 1/3, x2 = 1/3, x3 = 1/3, # Default reference points. Must sum to 1
    vertex_labels = tern22$alternatives, # Labels for the regions
    aes(fill = after_stat(vertex_labels)), 
    alpha = 0.3, color = NA, show.legend = FALSE
  ) +
  scale_fill_manual(
    values = c("ALP" = "red", "LNP" = "blue", "Other" = "grey70"),
    aesthetics = c("fill", "colour")
  )
```

## Order of vertex labels

When customizing your aesthetic mappings, you might stumble upon the issue of mismatch 
in value between the base layer's aesthetic mappings and the aesthetic mapping of `geom_ternary_region()This is because `geom_ternary_region()` generates its own data and does not inherit the
aesthetic from the base layer. 
The issue commonly comes in the message of `No shared levels found between `names(values)` of the manual scale and the data's fill values.`

You can specify the naming of the ternary regions using the `vertex_labels` argument. 
The default of `vertex_labels` is `c("Region 1", "Region 2", "Region 3")`.