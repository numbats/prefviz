---
title: "prefviz: Electoral Preference Change 2022 - 2025"

format: 
  revealjs:
    theme: default
    slide-number: true
    smaller: true
    scrollable: true
    fontsize: 34px
execute:
  echo: true
  warning: false
  message: false
  eval: false
code-fold: true
---

```{r setup}
#| include: false
#| eval: true
#| cache: true
source("poc1.R")
source(here::here("R/helmert_trans.R"))
```

## Overview

**Question:** How did electoral preferences change between 2022 and 2025?

**Plots**

- Distribution of preferences across geography (2025)
- Change in first preferences (2022 → 2025)
- Round-by-round preference flows (2025)

**Package components**

- Data: Input, wrappers
- Visualization core functions
- Helpers

# Plots

## 1. First preference distribution across electorates (2025)

```{r}
#| fig-height: 4
bscols(
  widths = c(4, 6),
  plotly_ternary,
  plotly_map
)
```

- Ternary plot on cartesian coordinate, compatible with ggplotly
- Linked to map view

**Next step:** Extend the ternary plot to multidimensionality, aiming for 5D for 6 parties

## 2. Change in first preferences (2022 → 2025)

::: {.columns}

::: {.column width="70%"}
```{r}
p_change
```
:::

::: {.column width="30%"}
Arrows show direction and magnitude of preference change

**Next step:** Include interactivity, display arrow in ggplotly
:::
:::

## 3. Round-by-round preference flows (2025)

::: {.columns}
::: {.column width="70%"}
```{r}
# Example: Wright electorate round-by-round
p_flow
```
:::

::: {.column width="30%"}
- Path through ternary space as preferences are distributed in each round. Start from the middle, end at one of the edges

**Next step:**

- Additional annotation on the round number
- Interactivity
:::
:::

# Package Components

## Data input

1. Distribution of preference: 2022, 2025

```{r}
#| echo: false
head(pref_2025)
```

2. Electoral boundaries and centroids: 2025

```{r}
#| echo: false
head(elb_df)
```

3. Preflib format: NSW Legislative

```{r}
#| echo: false
vote_data <- prefio::read_preflib("00058 - nswla/00058-00000171.soi", from_preflib = TRUE)
print(head(vote_data), width = Inf)
```

## Wrappers

- `bary2cart()` - Convert barycentric to cartesian
- `dop_irv()` - Extract distribution of preferences
- `polygon_shade()` - Split ternary space into regions

## `bary2cart()` - Convert barycentric coordinates to cartesian (Done)

```{r}
#| echo: true
#| eval: false
#| code-fold: false

bary2cart <- function(data, x, y, z){
  df <- data |> 
    mutate(
      cart_x = {{y}} + 0.5*{{z}},
      cart_y = sqrt(3/4)*{{z}}
    )

  return(df)
}
```

## `dop_irv()` - Use `prefio::pref_irv` to extract the distribution of preference (Done)

**From**
```{r}
print(head(vote_data), width = Inf)
```

**To**
```{r}
source(here::here("R/input_wrapper.R"))
dop_irv(vote_data, value_type = "percentage",
                preferences_col = preferences,
                frequency_col = frequency) |> 
  print(width = Inf)
```

<small>**Note:** `prefio::pref_irv()` has not been able to handle ties properly. For the context of IRV, this should be usable, but further consideration is needed for later iterations.</small>

## `polygon_share()` - Split the ternary space into 3 regions based on a central point (WIP)

Return a dataframe with the vertices of the polygon

```{r}
#| echo: true
#| eval: false
#| code-fold: false

polygon_shade <- function(cartesian = FALSE){
  regions <- tribble(
    ~ALP,   ~Other, ~LNP,   ~group,
    # ALP region
    33.33,  33.33,  33.33,  "ALP",
    50,     50,     0,      "ALP",
    100,    0,      0,      "ALP",
    50,     0,      50,     "ALP",
    33.33,  33.33,  33.33,  "ALP",
    # LNP region
    33.33,  33.33,  33.33,  "LNP",
    0,      50,     50,     "LNP",
    0,      0,      100,    "LNP",
    50,     0,      50,     "LNP",
    33.33,  33.33,  33.33,  "LNP",
    # Other region
    33.33,  33.33,  33.33,  "Other",
    50,     50,     0,      "Other",
    0,      100,    0,      "Other",
    0,      50,     50,     "Other",
    33.33,  33.33,  33.33,  "Other"
  )

  if(cartesian){
    regions <- bary2cart(regions, ALP, LNP, Other) |> 
      select(cart_x, cart_y, group)
  }

  return(regions)
}
```

## Core functions

- `ggtern_cartesian(data, x, y, z)` - Main plotting function, Draw the ternary plot on cartesian coordinate 
- `geom_polygon_shade()` - Split the ternary space into 3, given a central point

## `ggtern_cartesian(data, x, y, z)` - Ternary plot on cartesian (WIP)

- Main plotting function, Draw the ternary plot on cartesian coordinate 
```{r}
#| echo: true
#| eval: false

ggtern_cartesian <- function(data, x, y, z, label = TRUE, ...){
  # Define the triangle
  vertice <- data.frame(
    a = c(100, 0, 0),
    b = c(0, 0, 100),
    c = c(0, 100, 0)
  )
  vertice_df <- bary2cart(vertice, a, b, c) |> 
    rename(v_x = cart_x, v_y = cart_y)

  # Plot
  p <- bary2cart(data, {{x}}, {{y}}, {{z}}) |> 
    ggplot(aes(x = cart_x, y = cart_y, ...)) +
    geom_polygon(
      data = vertice_df,
      aes(x = v_x, y = v_y),
      fill = NA, color = "black"
    ) +
    theme_void() +
    coord_fixed(ratio = 1)

  # Add axis labels
  if(label){
    x_label <- rlang::as_label(rlang::ensym(x))
    y_label <- rlang::as_label(rlang::ensym(y))
    z_label <- rlang::as_label(rlang::ensym(z))
    
    p <- p +
      annotate(
        geom = "text", 
        x = c(0, 50, 100), 
        y = c(0, sqrt(3/4)*100, 0) + 5*c(-1, 1, -1), 
        label = c(x_label, z_label, y_label)
      )
  }

  return(p)
}
```

```{r example}
#| code-fold: false
ggtern_cartesian(
  pref_2025_centroid,
  x = ALP, y = LNP, z = Other) +
  geom_polygon(data = polygon_shade(cartesian = TRUE),
               aes(x = cart_x, y = cart_y, group = group),
               fill = NA, color = "grey50", alpha = 0.3) +
  geom_point(
    aes(color = ElectedParty, text = text), 
    size = 1, alpha = 0.8) +
  scale_color_manual(values = party_colors, name = "Elected Party")
```

## `geom_polygon_shade()` - Split the ternary space into 3, given a central point (WIP)

- Take the input from `polygon_shade()`
- Default as the central point (33.33, 33.33, 33.33)

```{r}
#| echo: true
#| eval: false
#| code-fold: false

geom_polygon_shade <- function(
  mapping = NULL,
  cartesian = TRUE,
  alpha = 0.3,
  color = "grey50",
  fill = NA,
  ...
) {
  
  regions <- polygon_shade(cartesian = cartesian)
  
  geom_polygon(
    data = regions,
    mapping = aes(x = cart_x, y = cart_y, group = group),
    alpha = alpha,
    color = color,
    fill = fill,
    inherit.aes = FALSE,
    ...
  )
}
```

# Next steps

- Extend the ternary plot to multidimensionality
- Interactivity for all plots, displayed in a Shiny app

# Helmert matrix + High dimensional plots

- `helmert_transform()` - Internal function to transform the compisitional input data to cartesian coordinates. Applied to all dimensions
- `ggtern_cart2d()` - Plot 2D ternary plot
- `ternary_tour()` - S3 object as input to `tourr::animate_xy()` and other `tourr` functions

## `helmert_transform()` 

`helmert_transform(data, alternatives = NULL)`

- Internal function, nested in 2 plotting functions
- Return a data frame with the original columns and additional columns containing the Helmert-transformed coordinates, named `x1`, `x2`, ..., `x(n-1)` where `n` is the number of dimensions in the compositional data.

```{r}
#| eval: true
#| echo: true
helmert_transform(pref_2025, alternatives = c("ALP", "LNP", "Other")) |> head()
```

## `ggtern_cart2d()` - Plot 2D ternary plot

`ggtern_cart2d(data, alternatives = NULL, label = TRUE, ...)`

- Main plotting function, Draw the ternary plot on cartesian coordinate

```{r}
#| eval: true
#| echo: true
first_pref_2025 <- pref_2025 |>
  filter(CountNumber == 0)

ggtern_cart2d(first_pref_2025, alternatives = c("ALP", "LNP", "Other")) +
  geom_point(aes(color = ElectedParty), size = 1, alpha = 0.8)
```

**Next step:** 

- Add geoms for labelling and spliting the ternary space
- Consider compatibility with `ggtern()`

## `ternary_tour()` - Input for `tourr::animate_xy()`

- S3 object
- Transform the compositional data to cartesian coordinates using `helmert_transform()`
- Define the simplex, edges and vertex labels

![](animation.gif)

```{r}
#| echo: true
#| code-fold: false
tour_obj <- ternary_tour(pref_2025_hd, alternatives = c(4:8))
animate_xy(tour_obj$data, 
           col = tour_obj$col,
           edges = tour_obj$edges,
           obs_labels = tour_obj$labels)
```

## `ternary_tour()` - Input for `tourr::animate_xy()`
```{r}
ternary_tour <- function(data, alternatives, ...) {
  # Transform data using helmert matrix
  cart_df <- helmert_transform(data, alternatives = alternatives) |>
    filter(CountNumber == 0)
  
  # Define the simplex
  simp <- geozoo::simplex(p = length(alternatives) - 1)
  sp <- data.frame(simp$points)
  colnames(sp) <- paste0("x", 1:ncol(sp))
  
  # Combine data
  cart_df_simp <- bind_rows(sp, cart_df)
  
  # Create labels
  labels <- c(alternatives, rep("", nrow(cart_df)))
  
  # Build the S3 object
  structure(
    list(
      data = cart_df_simp |> select(starts_with("x")),
      edges = as.matrix(simp$edges),
      labels = labels,
      col = cart_df_simp$alternatives,
      simplex = simp
    ),
    class = "ternary_tour"
  )
}

# Custom print method
print.ternary_tour <- function(x, ...) {
  cat("Ternary tour object\n")
  cat("Data dimensions:", nrow(x$data), "x", ncol(x$data), "\n")
  cat("Simplex vertices:", nrow(x$simplex$points), "\n")
  cat("Edges:", nrow(x$edges), "\n")
}
```